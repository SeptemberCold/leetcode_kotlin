package page003

/**
 *
 * 题目: 判断子序列
 *
 * 描述: 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
 *      字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。
 *      （例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
 * 限制: 0 <= s.length <= 100
 *      0 <= t.length <= 10^4
 *      两个字符串都只由小写字符组成。
 * 进阶: 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
 *
 * 链接:https://leetcode.cn/problems/is-subsequence/
 *
 */
object Leetcode392 {


    /**
     * 双指针
     * 执行用时：132 ms
     * 内存消耗：32.9 MB
     */
    fun isSubsequence(s: String, t: String): Boolean {
        if (s.isEmpty()) return true
        if (t.isEmpty()) return false
        var index = 0
        val ss = s.toCharArray()
        val ts = t.toCharArray()
        val sum = ss.size
        for (item in ts) {
            if (ss[index] == item) {
                index++
                if (index == sum) {
                    return true
                }
            }
        }
        return false
    }

    /**
     * 动态规划解法
     * 这种解法不适合用于这道题，而是用于项目工程里的
     * 在项目里使用要么提前初始化t 要么面对的s是一个庞大的数组
     * 只有满足这两种情况，这种解法才有意义
     * 因为单独使用，无论时间复杂度或空间复杂度都比不上双指针
     *
     * 执行用时：172 ms
     * 内存消耗：34.1 MB
     *
     * 这个性能测试的意义不大
     */
    fun isSubsequence2(s: String, t: String): Boolean {
        val n = s.length
        val m = t.length
        //创建一个数组 空间复杂度的开销基本在这了
        val f = Array(m + 1) { IntArray(26) }
        //最后一行全是m m表示数组里最大的数 也可以是大于m的数 只是用来标记的
        for (i in 0..25) {
            f[m][i] = m
        }
        //倒序初始化数组
        for (i in m - 1 downTo 0) {
            for (j in 0..25) {
                if (t[i].code == j + 'a'.code) f[i][j] = i else f[i][j] = f[i + 1][j]
            }
        }
        //开始判断
        var add = 0
        for (i in 0 until n) {
            if (f[add][s[i] - 'a'] == m) {
                return false
            }
            add = f[add][s[i] - 'a'] + 1
        }
        return true
    }
    /**
     *  如果t=bahbgdc 可得以下数组
     *
     *       [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z]
     *        |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
     *  0 =  [1, 0, 6, 5, 7, 7, 4, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
     *  1 =  [1, 3, 6, 5, 7, 7, 4, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
     *  2 =  [7, 3, 6, 5, 7, 7, 4, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
     *  3 =  [7, 3, 6, 5, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
     *  4 =  [7, 7, 6, 5, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
     *  5 =  [7, 7, 6, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
     *  6 =  [7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
     *  7 =  [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
     *
     *  如果s=abc
     *  在第0行找到 'a' = 1 跳到 1+1行
     *  在第2行找到 'b' = 3 跳到 3+1行
     *  在第4行找到 'c' = 6
     *  abc都找到了 所以s是t的子序列
     *
     *  如果s=axc
     *  在第0行找到 'a' = 1 跳到 1+1行
     *  在第2行找到 'x' = 7
     *  7等于t的长度，所以s不是t的子序列
     *
     *  以 t=bahbgdc s=abc 为例
     *  首先知道"s[0]=a"在t的第2个 对应第二行 表示下一次从第二行查找
     *  然后想知道出现"s[1]=b"在a后第一次出现的位置 在第4个 对应第四行 表示下一次从第四行查找
     *  然后想知道出现"s[2]=c"在b后第一次出现的位置 在第6个 对应第六行 表示下一次从第六行查找
     *  由于不需要查找了，所以确定s是t的子序列
     *
     *  以 t=bahbgdc s=abc 为例
     *  首先知道"s[0]=a"在t的第2个 对应第二行 表示下一次从第二行查找
     *  然后想知道出现"s[1]=x"在a后第一次出现的位置 没有找到 等于7表示后续没有
     *  所以确定s不是t的子序列
     *
     */


}